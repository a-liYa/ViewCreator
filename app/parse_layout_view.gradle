import groovy.util.slurpersupport.GPathResult
import groovy.util.slurpersupport.Node

project.afterEvaluate {
    Arrays.asList("mergeDebugResources", "mergeReleaseResources").each {
        println(it)
        def mergeResourcesTask = project.tasks.findByName(it)
        if (mergeResourcesTask != null) {
            def parseTask = project.tasks.create("$it#LayoutParseTask", LayoutResourcesParseTask.class)
            parseTask.inputFiles = mergeResourcesTask.inputs.files
            mergeResourcesTask.finalizedBy(parseTask)
        }
    }
}

class LayoutResourcesParseTask extends DefaultTask {

    File viewNamesFile
    FileCollection inputFiles
    HashSet<String> viewSet = new HashSet<>()
    List<String> ignoreViewNames = Arrays.asList("include", "fragment", "merge", "view", "DateTimeView",
            "com.google.android.material.datepicker.MaterialCalendarGridView")

    static final String LAYOUT_PATH = "layout"

    LayoutResourcesParseTask() {
    }

    @TaskAction
    void doTask() {
        File distDir = new File(project.buildDir, "tmp/mergeResourcesLayoutParse")
        if (!distDir.exists())
            distDir.mkdirs()

        viewNamesFile = new File(distDir, "view_names.txt")
        if (viewNamesFile.exists()) {
            viewNamesFile.delete()
        }
        viewNamesFile.createNewFile()

        viewSet.clear()
        viewSet.addAll(ignoreViewNames)

        // 遍历所有输入文件夹， 拼接 /layout 子文件
        inputFiles.each { inputFile ->
            if (!inputFile.isDirectory()) return

            def layoutDir = new File(inputFile, LAYOUT_PATH)
            if (!layoutDir.exists()) return

            // 遍历所有 inputFile/layout 里面的 layout xml 并解析
            layoutDir.listFiles().each { layoutFile ->

                if (!layoutFile.name.startsWith(".")) { // 过滤隐藏文件
                    GPathResult result = new XmlSlurper().parse(layoutFile)

                    String viewName = result.name()
                    if (viewSet.add(viewName)) { // 滤重
                        viewNamesFile.append("${viewName}\n")
                    }
                    // 解析根布局下的子节点 View
                    result.childNodes().forEachRemaining({ o ->
                        if (o instanceof Node) {
                            parseViewNode(o)
                        }
                    })
                }
            }
        }
    }

    void parseViewNode(Node node) {
        String viewName = node.name()
        if (viewSet.add(viewName)) {
            viewNamesFile.append("${viewName}\n")
        }
        node.childNodes().forEachRemaining({ o ->
            if (o instanceof Node) {
                parseViewNode(o)
            }
        })
    }
}